import json
import logging
from copy import deepcopy
from typing import Dict, Optional, Union, List, Tuple

from DCNM_errors import DCNMParameterError, DCNMInterfacesParameterError
from filters import filterfactory
from DCNM_connect import DcnmRestApi
from DCNM_utils import error_handler, _check_patterns, _check_response
from handler import DcnmComponent, Handler

logger = logging.getLogger(__name__)


class DcnmInterfaces(DcnmComponent):
    def __init__(self, handler: Handler, dcnm_connector: DcnmRestApi):
        super().__init__(handler, dcnm_connector)
        self.all_interfaces_details: Dict[tuple, dict] = {}
        self.all_interfaces_details_prev: Dict[tuple, dict] = {}
        self.all_interfaces_nvpairs: Dict[tuple, dict] = {}
        self.all_interfaces_nvpairs_prev: Dict[tuple, dict] = {}

    @error_handler("ERROR: get_all_interfaces_detail: getting interface details for serial number")
    def get_all_interfaces_details(self, serial_number: Optional[str] = None, interface: Optional[str] = None):
        """

        :param self:
        :type self:
        :param serial_number: optional filter
        :type serial_number: str
        :param interface: optional filter
        :type interface: str
        :return: dictionary of the form with entries for all switches
        {(interface['ifName'], interface['serialNo'],) = {
                'interface_name': interface['ifName'], 'interface_type': interface['ifType'],
                'fabric': interface['fabricName'], 'switch_name': interface['sysName'],
                'switch_serial': interface['serialNo'],
                'entity_id': interface['entityId'],
                'interface_policy': interface['underlayPoliciesStr'],
                'isPhysical': interface['isPhysical'],
                'interface_desc': interface['description']}
                }

        :rtype: dict[tuple, dict]

        pulls a list of all interfaces from dcnm of the following form. returns a dictionary with a subset of
        values

                [
          {
            "allowAccessAdmin": true,
            "allowAccessAdminReason": null,
            "adminStatus": 1,
            "adminStatusStr": "up",
            "alias": "",
            "allowedVLANs": null,
            "channelId": -1,
            "channelIfIndex": -1,
            "complianceStatus": "In-Sync",
            "deleteReason": null,
            "description": "mgmt0",
            "duplex": null,
            "editBlockReason": null,
            "entityId": "FDO24261WAT~mgmt0",
            "fabricName": "site-2",
            "ifIndex": 83886080,
            "ifName": "mgmt0",
            "ifType": "INTERFACE_MGMT",
            "interfaceDbId": 5169890,
            "ipAddress": "10.0.7.22/24",
            "isDeletable": true,
            "isDiscovered": true,
            "isFex": "false",
            "isPhysical": "true",
            "isRbacAccessible": "true",
            "mgmtIpAddress": "10.0.7.22",
            "mode": null,
            "mtu": 1500,
            "nativeVlanId": -1,
            "neighbours": [],
            "operStatusCause": "ok",
            "operStatusStr": "up",
            "overlayNetwork": [],
            "platform": "N9K",
            "policyChangeSupported": true,
            "portChannelMemberList": null,
            "serialNo": "FDO24261WAT",
            "speedValue": 1000000000,
            "switchDbId": 5164810,
            "sysName": "cl4001",
            "underlayPolicies": [
              {
                "id": 5164430,
                "policyId": "POLICY-5164430",
                "templateName": "int_mgmt_11_1",
                "entityName": "mgmt0",
                "entityType": "INTERFACE",
                "status": "NA",
                "lastModified": 1647552899176,
                "source": "",
                "serialNumber": "FDO24261WAT",
                "policyTag": null,
                "autoGenerated": true
              }
            ],
            "vdcId": 0,
            "vdcName": null,
            "vpcId": 0,
            "vrf": "management",
            "priMemberIntfList": null,
            "secMemberIntfList": null,
            "blockConfig": false,
            "underlayPolicySource": "",
            "underlayPolicyTag": "[interface_edit_policy]",
            "interfaceGroup": null,
            "hasDeletedOverlay": false,
            "externalFabric": false,
            "discovered": true,
            "aafexPort": false,
            "groupAssocSupported": true,
            "editAllowed": true,
            "deletable": true,
            "markDeleted": false
          },
          {
            "allowAccessAdmin": true,
            "allowAccessAdminReason": null,
            "adminStatus": 1,
            "adminStatusStr": "up",
            "alias": "TEST1",
            "allowedVLANs": "none",
            "channelId": -1,
            "channelIfIndex": -1,
            "complianceStatus": "In-Sync",
            "deleteReason": null,
            "description": "Ethernet1/1",
            "duplex": null,
            "editBlockReason": null,
            "entityId": "FDO24261WAT~Ethernet1/1",
            "fabricName": "site-2",
            "ifIndex": 436207616,
            "ifName": "Ethernet1/1",
            "ifType": "INTERFACE_ETHERNET",
            "interfaceDbId": 5169940,
            "ipAddress": null,
            "isDeletable": true,
            "isDiscovered": true,
            "isFex": "false",
            "isPhysical": "true",
            "isRbacAccessible": "true",
            "mgmtIpAddress": "10.0.7.22",
            "mode": "trunk",
            "mtu": 9216,
            "nativeVlanId": -1,
            "neighbours": [
              {
                "sysName": "U19-N9396-1",
                "switchid": 0,
                "type": "LAN",
                "ifName": "Ethernet1/45",
                "connectedToStr": "U19-N9396-1 (Ethernet1/45)",
                "discovered": false
              }
            ],
            "operStatusCause": "ok",
            "operStatusStr": "up",
            "overlayNetwork": [],
            "platform": "N9K",
            "policyChangeSupported": true,
            "portChannelMemberList": null,
            "serialNo": "FDO24261WAT",
            "speedValue": 10000000000,
            "switchDbId": 5164810,
            "sysName": "cl4001",
            "underlayPolicies": [
              {
                "id": 5262840,
                "policyId": "POLICY-5262840",
                "templateName": "int_trunk_host_11_1",
                "entityName": "Ethernet1/1",
                "entityType": "INTERFACE",
                "status": "NA",
                "lastModified": 1652218783957,
                "source": "",
                "serialNumber": "FDO24261WAT",
                "policyTag": null,
                "autoGenerated": true
              }
            ],
            "vdcId": 0,
            "vdcName": null,
            "vpcId": 0,
            "vrf": null,
            "priMemberIntfList": null,
            "secMemberIntfList": null,
            "blockConfig": false,
            "underlayPolicySource": "",
            "underlayPolicyTag": "[interface_edit_policy]",
            "interfaceGroup": null,
            "hasDeletedOverlay": false,
            "externalFabric": false,
            "discovered": true,
            "aafexPort": false,
            "groupAssocSupported": true,
            "editAllowed": true,
            "deletable": true,
            "markDeleted": false
          }]

        """

        local_all_interfaces_details: Dict[tuple, dict] = {}

        path = '/interface/detail'

        params = {'serialNumber': serial_number, 'ifName': interface}

        logger.info("get_all_interfaces_detail: getting interface details for serial number: {}".format(serial_number))
        response = _check_response(self.dcnm.get(path, params=params))
        # pprint(json.loads(response['MESSAGE']))

        for interface in json.loads(response['MESSAGE']):
            # print(interface)
            local_all_interfaces_details[(interface['ifName'], interface['serialNo'],)] = {
                'interface_name': interface['ifName'], 'interface_type': interface['ifType'],
                'fabric': interface['fabricName'], 'switch_name': interface['sysName'],
                'switch_serial': interface['serialNo'],
                'entity_id': interface['entityId'],
                'isPhysical': interface['isPhysical'],
                'interface_desc': interface['description'],
                'adminStatus': interface['adminStatusStr'],
                'operStatus': interface['operStatusStr'],
                'operStatusCause': interface['operStatusCause'],
                'fabricName': interface['fabricName']}
            if interface['underlayPolicies'] is not None:
                local_all_interfaces_details[(interface['ifName'], interface['serialNo'],)]['interface_policy'] = \
                    interface['underlayPolicies'][0]['templateName']
                local_all_interfaces_details[(interface['ifName'], interface['serialNo'],)]['policyId'] = \
                    interface['underlayPolicies'][0]['policyId']
            else:
                local_all_interfaces_details[(interface['ifName'], interface['serialNo'],)]['interface_policy'] = None
                local_all_interfaces_details[(interface['ifName'], interface['serialNo'],)]['policyId'] = None
        return local_all_interfaces_details

    def get_interfaces_details(self, serial_numbers: Optional[Union[list, tuple]] = None,
                               interface: Optional[str] = None,
                               policy: Optional[Union[str, List[str]]] = None,
                               oper: Optional[Union[str, List[str]]] = None,
                               physical: Optional[bool] = None,
                               save_to_file: Optional[str] = None,
                               save_prev: bool = False):
        """


        :param interface: interface or list of interfaces
        :type interface: str or list
        :param policy: name of a policy or a list of names
        :type policy: str or list
        :param oper: an operational state or list of operational states
        :type oper: str or list
        :param physical: true to get only physical interfaces, false to get only non-physical interfaces
        :type physical: bool
        :param serial_numbers: required list or tuple of switch serial numbers
        :type serial_numbers: list or tuple
        :param save_to_file: optional parameter, if None do not save, if str use as filename to save to
        :type save_to_file: None or str
        :param save_prev: if True and  attribute all_interfaces_nvpairs exists,
        copy to attribute all_interfaces_nvpairs_prev
        :type save_prev: bool

        pulls all interface detail information from dcnm for a list of serial numbers.
        saves to a dictionary of the following form with the attribute name all_interfaces_details

        {('mgmt0', 'FDO24261WAT'): {'interface_name': 'mgmt0', 'interface_type': 'INTERFACE_MGMT', 'fabric': 'site-2',
        'switch_name': 'cl4001', 'switch_serial': 'FDO24261WAT', 'entity_id': 'FDO24261WAT~mgmt0', 'isPhysical': 'true',
         'interface_desc': 'mgmt0', 'adminStatus': 'up', 'operStatus': 'up', 'operStatusCause': 'ok', 'fabricName':
         'site-2', 'interface_policy': 'int_mgmt_11_1', 'policyId': 'POLICY-5164430'}, ('Vlan100', 'FDO24261WAT'):
         {'interface_name': 'Vlan100', 'interface_type': 'INTERFACE_VLAN', 'fabric': 'site-2', 'switch_name':
         'cl4001', 'switch_serial': 'FDO24261WAT', 'entity_id': 'FDO24261WAT~Vlan100', 'isPhysical': 'false',
         'interface_desc': 'Vlan100', 'adminStatus': 'up', 'operStatus': 'up', 'operStatusCause': 'ok',
         'fabricName': 'site-2', 'interface_policy': None, 'policyId': None}}
        """
        logger.info("get interfaces details")
        if self.all_interfaces_details and not save_prev:
            self.all_interfaces_details.clear()
        elif self.all_interfaces_details and save_prev:
            self.all_interfaces_details_prev = deepcopy(self.all_interfaces_details)
            self.all_interfaces_details.clear()

        if serial_numbers and isinstance(serial_numbers, str):
            serial_numbers = [serial_numbers]

        if serial_numbers and isinstance(serial_numbers, (list, tuple)):

            for sn in serial_numbers:
                interfaces = self.get_all_interfaces_details(serial_number=sn, interface=interface)
                self.all_interfaces_details.update(interfaces)
        else:
            self.all_interfaces_details = self.get_all_interfaces_details(interface=interface)

        if isinstance(policy, str):
            policy = [policy]
        if isinstance(oper, str):
            oper = [oper]
        if policy or oper or physical:
            try:
                self.all_interfaces_details = DcnmInterfaces.get_filtered_interfaces_details(
                    self.all_interfaces_details,
                    policy=policy, operStatus=oper, isPhysical=physical)
                # logger.debug("get_interfaces_nvpairs: {}".format(self.all_interfaces_nvpairs))
            except DCNMParameterError:
                logger.critical("ERROR: get_interfaces_detail: serial_numbers must be a string or a list of strings\n"
                                "policy must be a string or a list of strings\n"
                                "oper must be a string or a list of strings")
                raise DCNMInterfacesParameterError("serial_numbers must be a string or a list of strings\n"
                                                   "policy must be a string or a list of strings\n"
                                                   "oper must be a string or a list of strings")

        if save_to_file is not None:
            with open(save_to_file, 'w') as f:
                f.write(str(self.all_interfaces_details))

    @error_handler("ERROR: get_all_interfaces_nvpairs: getting interface details and nvpairs for serial number")
    def get_all_interfaces_nvpairs(self, serial_number: Optional[str] = None,
                                   interface: Optional[str] = None) -> Dict[tuple, dict]:
        """


        :param serial_number: optional serial number of a switch
        :type serial_number: str
        :param interface: optional filter, ifName
        :type interface: str

        pulls all interface policy information from dcnm. can optionally filter by serial number or ifName
        saves to a dictionary of the following form with the attribute name all_interfaces_nvpairs

        {
        ('Ethernet1/38', 'FDO242600CW'): {'interfaces': [{'ifName': 'Ethernet1/38',
                                               'nvPairs': {'ADMIN_STATE': 'true',
                                                           'ALLOWED_VLANS': 'none',
                                                           'BPDUGUARD_ENABLED': 'no',
                                                           'CONF': 'no cdp '
                                                                   'enable',
                                                           'DESC': '',
                                                           'GF': '',
                                                           'INTF_NAME': 'Ethernet1/38',
                                                           'MTU': 'jumbo',
                                                           'POLICY_DESC': '',
                                                           'POLICY_ID': 'POLICY-5247430',
                                                           'PORTTYPE_FAST_ENABLED': 'true',
                                                           'PRIORITY': '450',
                                                           'PTP': 'false',
                                                           'SPEED': 'Auto'},
                                               'serialNumber': 'FDO242600CW'}],
                               'policy': 'int_trunk_host_11_1'},
        ('Ethernet1/38', 'FDO24261WAT'): {'interfaces': [{'ifName': 'Ethernet1/38',
                                               'nvPairs': {'ADMIN_STATE': 'true',
                                                           'ALLOWED_VLANS': 'none',
                                                           'BPDUGUARD_ENABLED': 'no',
                                                           'CONF': 'no cdp '
                                                                   'enable',
                                                           'DESC': '',
                                                           'GF': '',
                                                           'INTF_NAME': 'Ethernet1/38',
                                                           'MTU': 'jumbo',
                                                           'POLICY_DESC': '',
                                                           'POLICY_ID': 'POLICY-5258530',
                                                           'PORTTYPE_FAST_ENABLED': 'true',
                                                           'PRIORITY': '450',
                                                           'PTP': 'false',
                                                           'SPEED': 'Auto'},
                                               'serialNumber': 'FDO24261WAT'}],
                               'policy': 'int_trunk_host_11_1'}
                               }


        """

        # skip_save is a boolean. if true do not save interface information to the instance variable, instead return
        # the requested interface information dictionary
        # for use with get_interfaces_nvpairs method

        local_all_interfaces_nvpairs: Dict[tuple, dict] = {}

        path = '/interface'

        params = {'serialNumber': serial_number, 'ifName': interface}
        logger.info("get_all_interfaces_nvpairs: serial_number: {}".format(serial_number))
        response = _check_response(self.dcnm.get(path, params=params))
        logger.debug("get_all_interfaces_nvpairs: response: {}".format(response))
        for policy in json.loads(response['MESSAGE']):
            for interface in policy['interfaces']:
                # print(interface)
                local_all_interfaces_nvpairs[(interface['ifName'], interface['serialNumber'])] = {
                    'policy': policy['policy'], 'interfaces': [
                        interface
                    ]
                }

        return local_all_interfaces_nvpairs

    def get_interfaces_nvpairs(self, serial_numbers: Optional[Union[list, tuple]] = None,
                               interface: Optional[str] = None,
                               policy: Optional[Union[str, List[str]]] = None,
                               config: Optional[Union[str, List[str]]] = None,
                               non_config: Optional[Union[str, List[str]]] = None,
                               nv_pairs: Optional[List[Tuple[str, str]]] = None,
                               save_to_file: Optional[str] = None,
                               save_prev: bool = False):
        """

        :param nv_pairs: optional list of tuples of form [(nvpair key, regex to match value)]
        :type nv_pairs: list or tuple of tuples
        :param serial_numbers: required list or tuple of switch serial numbers
        :type serial_numbers: list or tuple
        :param non_config: optional regex or list of regexes of items missing from the config
        :type non_config: str or list of strings
        :param config: optional regex or list of regexes of items in the config
        :type config: str or list of strings
        :param policy: optional regex or list of regexes of policy names to match
        :type policy: str or list of strings
        :param interface: optional interface
        :type interface: str
        :param save_to_file: optional parameter, if None do not save, if str use as filename to save to
        :type save_to_file: None or str
        :param save_prev: if True and  attribute all_interfaces_nvpairs exists,
        copy to attribute all_interfaces_nvpairs_prev
        :type save_prev: bool

        pulls all interface policy information from dcnm for a list of serial numbers.
        saves to a dictionary of the following form with the attribute name all_interfaces_nvpairs
        """
        logger.info("get interfaces nvpairs")
        if self.all_interfaces_nvpairs and not save_prev:
            self.all_interfaces_nvpairs.clear()
        elif self.all_interfaces_nvpairs and save_prev:
            self.all_interfaces_nvpairs_prev = deepcopy(self.all_interfaces_nvpairs)
            self.all_interfaces_nvpairs.clear()

        if serial_numbers and isinstance(serial_numbers, str):
            serial_numbers = [serial_numbers]

        if serial_numbers and isinstance(serial_numbers, (list, tuple)):

            for sn in serial_numbers:
                interfaces = self.get_all_interfaces_nvpairs(serial_number=sn, interface=interface)
                self.all_interfaces_nvpairs.update(interfaces)
        else:
            self.all_interfaces_nvpairs = self.get_all_interfaces_nvpairs(interface=interface)

        if isinstance(policy, str):
            policy = [policy]
        if isinstance(config, str):
            config = [config]
        if isinstance(non_config, str):
            non_config = [non_config]
        if policy or config or non_config or nv_pairs:
            try:
                self.all_interfaces_nvpairs = DcnmInterfaces.get_filtered_interfaces_nvpairs(
                    self.all_interfaces_nvpairs,
                    policy=policy, CONF=config,
                    nonCONF=non_config,
                    nvPairs=nv_pairs)
                # logger.debug("get_interfaces_nvpairs: {}".format(self.all_interfaces_nvpairs))
            except DCNMParameterError:
                logger.critical("ERROR: get_interfaces_nvpairs: serial_numbers must be a string or a list of strings\n"
                                "policy must be a string or a list of strings\n"
                                "nv_pairs must be a list of tuples of two strings\n"
                                "config must be a string or a list of strings")
                raise DCNMInterfacesParameterError("serial_numbers must be a string or a list of strings\n"
                                                   "policy must be a string or a list of strings\n"
                                                   "nv_pairs must be a list of tuples of two strings\n"
                                                   "config must be a string or a list of strings")

        if save_to_file is not None:
            with open(save_to_file, 'w') as f:
                f.write(str(self.all_interfaces_nvpairs))

    def get_interface_details(self, serial_number, interface):
        return self.all_interfaces_details.get((interface, serial_number))

    def get_interface_nvpairs(self, serial_number, interface):
        return self.all_interfaces_nvpairs.get((interface, serial_number))

    @staticmethod
    def get_filtered_interfaces_nvpairs(interfaces_nv_pairs: dict, policy: Optional[Union[str, List[str]]] = None,
                                        CONF: Optional[Union[str, List[str]]] = None,
                                        nonCONF: Optional[Union[str, List[str]]] = None,
                                        nvPairs: Optional[List[Tuple[str, str]]] = None,
                                        ) -> dict:
        """

        :param interfaces_nv_pairs: dictionary of interface policy details including nvpairs
        :type interfaces_nv_pairs: dict
        :param policy: a policy name or list of policy names to match
        :type policy: optional str or list of strings
        :param CONF: configuration or list of configurations to match
        :type CONF: optional str or list of strings
        :param nonCONF: a missing configuration of list of configurations to match
        :type nonCONF: optional str or list of strings
        :param nvPairs: a list of key value tuples within nvpairs to match
        :type nvPairs: optional list of tuples of form (str, str)
        :return: a new dictionary with only the entries that match all patterns
        :rtype: dict

        provide a dictionary of interface policies of the below form. it filters out all elements that do not match the
        provided patterns and returns a new dictionary with only those elements.

        {
            ('Ethernet1/38', 'FDO242600CW'): {
                'interfaces': [
                    {
                        'ifName': 'Ethernet1/38',
                        'nvPairs': {
                            'ADMIN_STATE': 'true',
                            'ALLOWED_VLANS': 'none',
                            'BPDUGUARD_ENABLED': 'no',
                            'CONF': 'no cdp '
                                                                           'enable',
                            'DESC': '',
                            'GF': '',
                            'INTF_NAME': 'Ethernet1/38',
                            'MTU': 'jumbo',
                            'POLICY_DESC': '',
                            'POLICY_ID': 'POLICY-5247430',
                            'PORTTYPE_FAST_ENABLED': 'true',
                            'PRIORITY': '450',
                            'PTP': 'false',
                            'SPEED': 'Auto'
                        },
                        'serialNumber': 'FDO242600CW'
                    }
                ],
                'policy': 'int_trunk_host_11_1'
            },
            ('Ethernet1/38', 'FDO24261WAT'): {
                'interfaces': [
                    {
                        'ifName': 'Ethernet1/38',
                        'nvPairs': {
                            'ADMIN_STATE': 'true',
                            'ALLOWED_VLANS': 'none',
                            'BPDUGUARD_ENABLED': 'no',
                            'CONF': 'no cdp '
                                                                           'enable',
                            'DESC': '',
                            'GF': '',
                            'INTF_NAME': 'Ethernet1/38',
                            'MTU': 'jumbo',
                            'POLICY_DESC': '',
                            'POLICY_ID': 'POLICY-5258530',
                            'PORTTYPE_FAST_ENABLED': 'true',
                            'PRIORITY': '450',
                            'PTP': 'false',
                            'SPEED': 'Auto'
                        },
                        'serialNumber': 'FDO24261WAT'
                    }
                ],
                'policy': 'int_trunk_host_11_1'
            }
        }
        """
        interfaces_nv_pairs_local = deepcopy(interfaces_nv_pairs)

        if isinstance(policy, str):
            policy = [policy]
        if isinstance(CONF, str):
            CONF = [CONF]
        if isinstance(nonCONF, str):
            nonCONF = [nonCONF]

        filter_dict = {'policy': policy, 'CONF': CONF, 'nvPairs': nvPairs}
        filters = filterfactory(filter_dict)
        if filters or nonCONF:
            try:
                for interface, interface_policy in deepcopy(interfaces_nv_pairs_local).items():
                    if filters:
                        if not all(f.match(interface_policy) for f in filters):
                            del interfaces_nv_pairs_local[interface]

                    if nonCONF:
                        if _check_patterns(nonCONF, interface_policy['interfaces'][0]['nvPairs']['CONF']):
                            del interfaces_nv_pairs_local[interface]
                            continue

            except DCNMParameterError:
                logger.error("ERROR: get_filtered_interfaces_nvpairs: Failed filtering nvpairs dictionary for {}".format(
                    interfaces_nv_pairs))
                logger.error(
                    "ERROR: get_filtered_interfaces_nvpairs: Error in filters: policy {} or config {} or nv_pairs {}".format(
                        policy, CONF, nvPairs))
                raise DCNMInterfacesParameterError("serial_numbers must be a string or a list of strings\n"
                                                   "policy must be a string or a list of strings\n"
                                                   "nv_pairs must be a list of tuples of two strings\n"
                                                   "config must be a string or a list of strings")
        return interfaces_nv_pairs_local

    @staticmethod
    def get_filtered_interfaces_details(interfaces_details, policy: Optional[Union[str, List[str]]] = None,
                                        operStatus: Optional[Union[str, List[str]]] = None,
                                        isPhysical: Optional[str] = None):
        """

        :param interfaces_details:
        :type interfaces_details:
        :param policy:
        :type policy:
        :param operStatus:
        :type operStatus:
        :param isPhysical:
        :type isPhysical:
        :return:
        :rtype:
        """
        interfaces_details_local = deepcopy(interfaces_details)

        if isinstance(policy, str):
            policy = [policy]
        if isinstance(operStatus, str):
            operStatus = [operStatus]
        filter_dict = {'policy': policy, 'operStatus': operStatus}
        filters = filterfactory(filter_dict)

        if filters or isPhysical:
            try:
                for interface, interface_policy in deepcopy(interfaces_details_local).items():
                    if filters:
                        if not all(f.match(interface_policy) for f in filters):
                            del interfaces_details_local[interface]

                    if isPhysical is not None:
                        if interface_policy['isPhysical'] is not isPhysical:
                            del interfaces_details_local[interface]
                            continue

            except DCNMParameterError:
                logger.error("ERROR: get_filtered_interfaces_details: Failed filtering details dictionary for {}".format(
                    interfaces_details))
                logger.error(
                    "ERROR: get_filtered_interfaces_details: Error in filters: policy {} or oper {}".format(
                        policy, operStatus))
                raise DCNMInterfacesParameterError("serial_numbers must be a string or a list of strings\n"
                                                   "policy must be a string or a list of strings\n"
                                                   "oper must be a string or a list of strings")
        return interfaces_details_local
